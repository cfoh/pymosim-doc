
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>comm.transceiver module &#8212; PyMoSim v0.8 Manual</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="node package" href="node.html" />
    <link rel="prev" title="comm.signalwave module" href="comm.signalwave.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="index.html">
<p class="title">PyMoSim</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="comm.html">
  comm package
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="node.html">
  node package
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="sim.html">
  sim package
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="map.html">
  map package
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/cfoh/pymosim" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="comm.channel.html">
   comm.channel module
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="comm.ltemodel.html">
   comm.ltemodel module
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="comm.mmwave28.html">
   comm.mmwave28 module
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="comm.signalwave.html">
   comm.signalwave module
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   comm.transceiver module
  </a>
 </li>
</ul>

  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#list-of-classes">
   List of Classes
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#basetransceiver">
     <code class="xref py py-class docutils literal notranslate">
      <span class="pre">
       BaseTransceiver
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#transceiver">
     <code class="xref py py-class docutils literal notranslate">
      <span class="pre">
       Transceiver
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#transceiverdir">
     <code class="xref py py-class docutils literal notranslate">
      <span class="pre">
       TransceiverDir
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#usertransceiver">
     <code class="xref py py-class docutils literal notranslate">
      <span class="pre">
       UserTransceiver
      </span>
     </code>
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="module-comm.transceiver">
<span id="comm-transceiver-module"></span><h1>comm.transceiver module<a class="headerlink" href="#module-comm.transceiver" title="Permalink to this headline">¶</a></h1>
<p>Module <cite>transceiver</cite> contains <cite>Transceiver</cite> class which interacts with 
a channel. Each transceiver must carry a <cite>Channel</cite>. 
The operations related to a transmission that a transceiver can do includes:</p>
<ul class="simple">
<li><p>create_signal(): to create a signal for transmission. It is an abstract method in the
base class.</p></li>
<li><p>multicast(): to multicast a created signal from this transceiver. This 
method can also be used for unicast. It is an abstract method in the base class.</p></li>
<li><p>can_detect(): to check if an arriving signal can be detected and decoded. 
It is an abstract method in the base class.</p></li>
<li><p>broadcast(): to broadcast a created signal from this transceiver.</p></li>
<li><p>unicast(): to unicast a created signal from this transceiver to another node.
by the receiving transceiver.</p></li>
</ul>
<div class="section" id="list-of-classes">
<h2>List of Classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="basetransceiver">
<h3><a class="reference internal" href="#comm.transceiver.BaseTransceiver" title="comm.transceiver.BaseTransceiver"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseTransceiver</span></code></a><a class="headerlink" href="#basetransceiver" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>This is the base transceiver. It provides specification and several
useful methods.</p>
</div></blockquote>
</div>
<div class="section" id="transceiver">
<h3><a class="reference internal" href="#comm.transceiver.Transceiver" title="comm.transceiver.Transceiver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transceiver</span></code></a><a class="headerlink" href="#transceiver" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>This is a simple omni-directional transceiver design.
It uses <a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a>.</p>
</div></blockquote>
</div>
<div class="section" id="transceiverdir">
<h3><a class="reference internal" href="#comm.transceiver.TransceiverDir" title="comm.transceiver.TransceiverDir"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransceiverDir</span></code></a><a class="headerlink" href="#transceiverdir" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>This is a simple directional transceiver design. 
It uses <a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a>.</p>
</div></blockquote>
</div>
<div class="section" id="usertransceiver">
<h3><a class="reference internal" href="#comm.transceiver.UserTransceiver" title="comm.transceiver.UserTransceiver"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserTransceiver</span></code></a><a class="headerlink" href="#usertransceiver" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>This is a user-defined transceiver design. It allows the
user to spefify a callback function to perform the
signal propagation and detection logic at the user
simulation level.</p>
</div></blockquote>
<hr class="docutils" />
<dl class="py class">
<dt id="comm.transceiver.BaseTransceiver">
<em class="property">class </em><code class="sig-prename descclassname">comm.transceiver.</code><code class="sig-name descname">BaseTransceiver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">channel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>This is a class providing functions to simulate transceiver operations.</p>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.broadcast" title="comm.transceiver.BaseTransceiver.broadcast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast</span></code></a>(signal)</p></td>
<td><p>This method allows a node to perform a broadcast on the channel,  and the method returns a list of tuple (node,received_signal) that the broadcast signal can be decoded, or None if no node can decode the signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.can_detect" title="comm.transceiver.BaseTransceiver.can_detect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">can_detect</span></code></a>(signal)</p></td>
<td><p>This method allows a receiving node to check if a receiving signal can be successfully detected and decoded.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.create_signal" title="comm.transceiver.BaseTransceiver.create_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_signal</span></code></a>()</p></td>
<td><p>Create a signal for transmissioin.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.get_carrier_freq" title="comm.transceiver.BaseTransceiver.get_carrier_freq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_carrier_freq</span></code></a>()</p></td>
<td><p>Return the carrier frequency used by the channel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.get_property" title="comm.transceiver.BaseTransceiver.get_property"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_property</span></code></a>([property])</p></td>
<td><p>The method returns the property of the transceiver.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.get_type" title="comm.transceiver.BaseTransceiver.get_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_type</span></code></a>()</p></td>
<td><p>This method returns the type of the transceiver.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.multicast" title="comm.transceiver.BaseTransceiver.multicast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multicast</span></code></a>(signal, node_list)</p></td>
<td><p>This method allows a node to perform a multicast on the channel,  and the method returns a list of tuple (node,received_signal) that the multicast signal can decoded, or an empty list if no node can decode the signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.set_property" title="comm.transceiver.BaseTransceiver.set_property"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_property</span></code></a>(key, value)</p></td>
<td><p>Set a property to this transceiver.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.BaseTransceiver.unicast" title="comm.transceiver.BaseTransceiver.unicast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unicast</span></code></a>(signal, node)</p></td>
<td><p>This method allows a node to perform a unicast on the channel,  and the method returns a tuple (node,received_signal) if the  signal can be decoded, or None.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">channel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the constructor.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>node</strong><span class="classifier"><a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a> subclass</span></dt><dd><p>The node that contains the transceiver.</p>
</dd>
<dt><strong>freq</strong><span class="classifier">float</span></dt><dd><p>Carrier frequency of the transceiver.</p>
</dd>
<dt><strong>channel</strong><span class="classifier"><a class="reference internal" href="comm.channel.html#comm.channel.BaseChannel" title="comm.channel.BaseChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.channel.BaseChannel</span></code></a> subclass</span></dt><dd><p>The channel that the transceiver uses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.get_carrier_freq">
<code class="sig-name descname">get_carrier_freq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.get_carrier_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the carrier frequency used by the channel.</p>
<dl class="simple">
<dt>float</dt><dd><p>The frequency used by the channel.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.create_signal">
<em class="property">abstract </em><code class="sig-name descname">create_signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.create_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signal for transmissioin. This is an abstract method 
to be properly implemented in the subclass.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.multicast">
<em class="property">abstract </em><code class="sig-name descname">multicast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em>, <em class="sig-param"><span class="n">node_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.multicast" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows a node to perform a multicast on the channel, 
and the method returns a list of tuple (node,received_signal)
that the multicast signal can decoded, or an empty list if no node can
decode the signal.
This is an abstract method to be properly implemented in the subclass.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.can_detect">
<em class="property">abstract </em><code class="sig-name descname">can_detect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#comm.transceiver.BaseTransceiver.can_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows a receiving node to check if a receiving signal
can be successfully detected and decoded. In practice, a receiving
signal can be decoded if its SNR passes a specific threshold.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.broadcast">
<code class="sig-name descname">broadcast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows a node to perform a broadcast on the channel, 
and the method returns a list of tuple (node,received_signal)
that the broadcast signal can be decoded, or None if no node can
decode the signal. This method uses <cite>multicast()</cite> with all nodes
in the simulation world to achieve broadcast.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.unicast">
<code class="sig-name descname">unicast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em>, <em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.unicast" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows a node to perform a unicast on the channel, 
and the method returns a tuple (node,received_signal) if the 
signal can be decoded, or None. This method uses <cite>multicast()</cite> with
a single node in the list to achieve unicast.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.get_type">
<code class="sig-name descname">get_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.get_type" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the type of the transceiver.</p>
<dl class="simple">
<dt>str</dt><dd><p>The type of the transceiver.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.get_property">
<code class="sig-name descname">get_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">property</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.get_property" title="Permalink to this definition">¶</a></dt>
<dd><p>The method returns the property of the transceiver. 
If input <cite>property</cite> is not given it returns a dictionary containing all 
properties of this transceiver. Currently, it is used to store illustrative coverage
that can be retrieved and illustrated on the animation during simulation.</p>
<p>The property list given in dict used in this module includes the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## default (inherited from BaseTransceiver and left unchanged)</span>
<span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;unknown&quot;</span><span class="p">,</span>
    <span class="s2">&quot;freq&quot;</span><span class="p">:</span> <span class="n">carrier_frequency</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">## omni directional transmission</span>
<span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;omni&quot;</span><span class="p">,</span>
    <span class="s2">&quot;freq&quot;</span><span class="p">:</span> <span class="n">carrier_frequency</span><span class="p">,</span>
    <span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">the_radius_in_pixel</span>
<span class="p">}</span>

<span class="c1">## directional transmission</span>
<span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;directional&quot;</span><span class="p">,</span>
    <span class="s2">&quot;freq&quot;</span><span class="p">:</span> <span class="n">carrier_frequency</span><span class="p">,</span>
    <span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">the_radius_in_num_of_pixel</span><span class="p">,</span>
    <span class="s2">&quot;azimuth&quot;</span><span class="p">:</span> <span class="n">the_pointing_direction_in_degree</span><span class="p">,</span>
    <span class="s2">&quot;beam width&quot;</span><span class="p">:</span> <span class="n">the_beam_width_in_degree</span>
<span class="p">}</span>

<span class="c1">## user-defined default properties</span>
<span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;user-defined&quot;</span>
    <span class="s2">&quot;freq&quot;</span><span class="p">:</span> <span class="n">carrier_frequency</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>property</strong><span class="classifier">str, optional, default=None</span></dt><dd><p>The property to get. If no property is given, it returns all properties
in a form of dictionary.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Value or Dict</dt><dd><p>If the input property is specified, the corresponding value will be
returned, or None is returned if not found. If no property is given,
A dictionary containing all properties of this transceiver will be returned.
The dictionary will contain a key <cite>type</cite> to describe the type used
for this transceiver.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.BaseTransceiver.set_property">
<code class="sig-name descname">set_property</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.BaseTransceiver.set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a property to this transceiver. If <cite>key</cite> already exists, its value 
will be replaced. This property storage facilitates keeping of any 
information during the creation time that can be retrieved during the 
simulation time, for example illustrative coverage of the transceiver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">any</span></dt><dd><p>The key to use for the property. Ideally, it should be a str.</p>
</dd>
<dt><strong>value</strong><span class="classifier">any</span></dt><dd><p>The value for the given key.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="comm.transceiver.Transceiver">
<em class="property">class </em><code class="sig-prename descclassname">comm.transceiver.</code><code class="sig-name descname">Transceiver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">channel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.Transceiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#comm.transceiver.BaseTransceiver" title="comm.transceiver.BaseTransceiver"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.transceiver.BaseTransceiver</span></code></a></p>
<p>This is a class providing functions to simulate transceiver operations.</p>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast</span></code>(signal)</p></td>
<td><p>This method allows a node to perform a broadcast on the channel,  and the method returns a list of tuple (node,received_signal) that the broadcast signal can be decoded, or None if no node can decode the signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#comm.transceiver.Transceiver.can_detect" title="comm.transceiver.Transceiver.can_detect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">can_detect</span></code></a>(signal)</p></td>
<td><p>See also the base class for description, this method allows a receiving node to  check if a receiving signal can be successfully detected and decoded.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.Transceiver.create_signal" title="comm.transceiver.Transceiver.create_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_signal</span></code></a>()</p></td>
<td><p>Create a signal for transmissioin.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_carrier_freq</span></code>()</p></td>
<td><p>Return the carrier frequency used by the channel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_property</span></code>([property])</p></td>
<td><p>The method returns the property of the transceiver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_type</span></code>()</p></td>
<td><p>This method returns the type of the transceiver.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.Transceiver.multicast" title="comm.transceiver.Transceiver.multicast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multicast</span></code></a>(signal, node_list)</p></td>
<td><p>This method allows a node to perform a multicast on the channel,  and the method returns a list of tuple (node,received_signal) that the multicast signal can be decoded, or None if no node can decode the signal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_property</span></code>(key, value)</p></td>
<td><p>Set a property to this transceiver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unicast</span></code>(signal, node)</p></td>
<td><p>This method allows a node to perform a unicast on the channel,  and the method returns a tuple (node,received_signal) if the  signal can be decoded, or None.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="comm.transceiver.Transceiver.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">channel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.Transceiver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the constructor.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>node</strong><span class="classifier"><a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a> subclass</span></dt><dd><p>The node that contains the transceiver.</p>
</dd>
<dt><strong>freq</strong><span class="classifier">float</span></dt><dd><p>Carrier frequency of the transceiver.</p>
</dd>
<dt><strong>channel</strong><span class="classifier"><a class="reference internal" href="comm.channel.html#comm.channel.BaseChannel" title="comm.channel.BaseChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.channel.BaseChannel</span></code></a> subclass</span></dt><dd><p>The channel that the transceiver uses.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.Transceiver.create_signal">
<code class="sig-name descname">create_signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal">comm.signalwave.QualityBasedSignal</a><a class="headerlink" href="#comm.transceiver.Transceiver.create_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signal for transmissioin.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.Transceiver.multicast">
<code class="sig-name descname">multicast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span><span class="p">:</span> <span class="n"><a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal">comm.signalwave.QualityBasedSignal</a></span></em>, <em class="sig-param"><span class="n">node_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.Transceiver.multicast" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows a node to perform a multicast on the channel, 
and the method returns a list of tuple (node,received_signal)
that the multicast signal can be decoded, or None if no node can
decode the signal.
Note that this method can be used for unicast by putting a single node
in <cite>node_list</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>signal</strong><span class="classifier"><a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a></span></dt><dd><p>The signal to be transmitted. Use <cite>create_signal()</cite> method to create one.</p>
</dd>
<dt><strong>node_list</strong><span class="classifier">a list of <a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a> subclass</span></dt><dd><p>The list containing the nodes to receive the multicast signal</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A list of tuple (<a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a>, <a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a>)</dt><dd><p>It returns a list of (node,signal) that the node can decode the 
signal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.Transceiver.can_detect">
<code class="sig-name descname">can_detect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#comm.transceiver.Transceiver.can_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>See also the base class for description, this method allows a receiving node to 
check if a receiving signal can be successfully detected and decoded. In this
implementation, it checks if the signal quality is zero for failed decoding, and 
any non-zero positive value for successful decoding.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="comm.transceiver.TransceiverDir">
<em class="property">class </em><code class="sig-prename descclassname">comm.transceiver.</code><code class="sig-name descname">TransceiverDir</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">channel</span></em>, <em class="sig-param"><span class="n">beam_width</span></em>, <em class="sig-param"><span class="n">azimuth</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.TransceiverDir" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#comm.transceiver.BaseTransceiver" title="comm.transceiver.BaseTransceiver"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.transceiver.BaseTransceiver</span></code></a></p>
<p>This is a class providing functions to simulate transceiver operations 
with directional antenna. Its transmission and receiption are directional.</p>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast</span></code>(signal)</p></td>
<td><p>This method allows a node to perform a broadcast on the channel,  and the method returns a list of tuple (node,received_signal) that the broadcast signal can be decoded, or None if no node can decode the signal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#comm.transceiver.TransceiverDir.can_detect" title="comm.transceiver.TransceiverDir.can_detect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">can_detect</span></code></a>(signal)</p></td>
<td><p>See also the base class for description, this method allows a receiving node to  check if a receiving signal can be successfully detected and decoded.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.TransceiverDir.create_signal" title="comm.transceiver.TransceiverDir.create_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_signal</span></code></a>()</p></td>
<td><p>Create a signal for transmissioin.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_carrier_freq</span></code>()</p></td>
<td><p>Return the carrier frequency used by the channel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_property</span></code>([property])</p></td>
<td><p>The method returns the property of the transceiver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_type</span></code>()</p></td>
<td><p>This method returns the type of the transceiver.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.TransceiverDir.multicast" title="comm.transceiver.TransceiverDir.multicast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multicast</span></code></a>(signal, node_list)</p></td>
<td><p>This method allows a node to perform a multicast on the channel,  and the method returns a list of tuple (node,received_signal) that the multicast signal can be decoded, or None if no node can decode the signal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_property</span></code>(key, value)</p></td>
<td><p>Set a property to this transceiver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unicast</span></code>(signal, node)</p></td>
<td><p>This method allows a node to perform a unicast on the channel,  and the method returns a tuple (node,received_signal) if the  signal can be decoded, or None.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="comm.transceiver.TransceiverDir.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">freq</span></em>, <em class="sig-param"><span class="n">channel</span></em>, <em class="sig-param"><span class="n">beam_width</span></em>, <em class="sig-param"><span class="n">azimuth</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.TransceiverDir.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the constructor.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>node</strong><span class="classifier"><a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a> subclass</span></dt><dd><p>The node that contains the transceiver.</p>
</dd>
<dt><strong>freq</strong><span class="classifier">float</span></dt><dd><p>Carrier frequency of the transceiver.</p>
</dd>
<dt><strong>channel</strong><span class="classifier"><a class="reference internal" href="comm.channel.html#comm.channel.BaseChannel" title="comm.channel.BaseChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.channel.BaseChannel</span></code></a> subclass</span></dt><dd><p>The channel that the transceiver uses.</p>
</dd>
<dt><strong>beam_width</strong><span class="classifier">float</span></dt><dd><p>The beam width (in degrees) of the sector model. Setting it to 360 will turn 
it to omnidirectional setup.</p>
</dd>
<dt><strong>azimuth</strong><span class="classifier">float</span></dt><dd><p>The pointing direction of the beam. Setting 0 degree means north pointing, 
the degree indicates clockwise angle from the north.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.TransceiverDir.create_signal">
<code class="sig-name descname">create_signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal">comm.signalwave.QualityBasedSignal</a><a class="headerlink" href="#comm.transceiver.TransceiverDir.create_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signal for transmissioin.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.TransceiverDir.multicast">
<code class="sig-name descname">multicast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span><span class="p">:</span> <span class="n"><a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal">comm.signalwave.QualityBasedSignal</a></span></em>, <em class="sig-param"><span class="n">node_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.TransceiverDir.multicast" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows a node to perform a multicast on the channel, 
and the method returns a list of tuple (node,received_signal)
that the multicast signal can be decoded, or None if no node can
decode the signal.
Note that this method can be used for unicast by putting a single node
in <cite>node_list</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>signal</strong><span class="classifier"><a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a></span></dt><dd><p>The signal to be transmitted. Use <cite>create_signal()</cite> method to create one.</p>
</dd>
<dt><strong>node_list</strong><span class="classifier">a list of <a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a> subclass</span></dt><dd><p>The list containing the nodes to receive the multicast signal</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A list of tuple (<a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a>, <a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a>)</dt><dd><p>It returns a list of (node,signal) that the node can decode the 
signal. <cite>signal.quality</cite> contains the signal quality from 0 to 1,
where 0 indicates cannot be decoded, 1 indicates highest quality.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.TransceiverDir.can_detect">
<code class="sig-name descname">can_detect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#comm.transceiver.TransceiverDir.can_detect" title="Permalink to this definition">¶</a></dt>
<dd><p>See also the base class for description, this method allows a receiving node to 
check if a receiving signal can be successfully detected and decoded. In this
implementation, for unsuccessful decoding, it checks firstly if the signal quality 
is zero, then checks if the travelling direction is covered by the sector covering
direction.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="comm.transceiver.UserTransceiver">
<em class="property">class </em><code class="sig-prename descclassname">comm.transceiver.</code><code class="sig-name descname">UserTransceiver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">freq</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.UserTransceiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#comm.transceiver.BaseTransceiver" title="comm.transceiver.BaseTransceiver"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.transceiver.BaseTransceiver</span></code></a></p>
<p>This abstract class provides a transceiver specification allowing user to 
define its behaviour. This class should be extended to a subclass for actual
use. Bedides, this class should use a signal extended from 
<a class="reference internal" href="comm.signalwave.html#comm.signalwave.BaseSignal" title="comm.signalwave.BaseSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.BaseSignal</span></code></a>. A simple choice is to use
<a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a>. By default, this class
provides <cite>create_signal()</cite> to create a signal of
<a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a>.</p>
<p>The transceiver provides <cite>unicast()</cite>, <cite>multicast()</cite> and <cite>broadcast()</cite>
methods for a transmitter to transmit a signal to others. The signal 
will be delivered to all relevant transceiver instances to process. For
<cite>broadcast()</cite>, all transceivers will receive the signal. For <cite>unicast()</cite>
or <cite>multicast()</cite>, only those specified as a receiver will receive the signal.</p>
<p>The subclass must implement the following abstract method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">can_detect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span>
</pre></div>
</div>
<p>The above method is a listener listening to any incoming signal. It is 
called when there is a signal arriving to this transceiver. The subclass
must implement the signal propagation and detection logic,
and eventually return a True/False to indicate whether the signal can be 
detected successfully. The <cite>signal</cite> input is a copy of the transmitted 
signal which can be modified after the propagation and detection. The
signal will eventually be returned back to the user simulation for any 
further evaluation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>node</strong><span class="classifier"><a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a> subclass</span></dt><dd><p>The node that contains the transceiver.</p>
</dd>
<dt><strong>freq</strong><span class="classifier">float</span></dt><dd><p>Carrier frequency of the transceiver.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast</span></code>(signal)</p></td>
<td><p>This method allows a node to perform a broadcast on the channel,  and the method returns a list of tuple (node,received_signal) that the broadcast signal can be decoded, or None if no node can decode the signal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">can_detect</span></code>(signal)</p></td>
<td><p>This method allows a receiving node to check if a receiving signal can be successfully detected and decoded.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.UserTransceiver.create_signal" title="comm.transceiver.UserTransceiver.create_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_signal</span></code></a>()</p></td>
<td><p>Create a signal for transmissioin.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_carrier_freq</span></code>()</p></td>
<td><p>Return the carrier frequency used by the channel.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_property</span></code>([property])</p></td>
<td><p>The method returns the property of the transceiver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_type</span></code>()</p></td>
<td><p>This method returns the type of the transceiver.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#comm.transceiver.UserTransceiver.multicast" title="comm.transceiver.UserTransceiver.multicast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multicast</span></code></a>(signal, node_list)</p></td>
<td><p>This method allows a node to perform a multicast,  and the method returns a list of tuple (node,received_signal) that the multicast signal can be decoded, or None if no node can decode the signal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_property</span></code>(key, value)</p></td>
<td><p>Set a property to this transceiver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unicast</span></code>(signal, node)</p></td>
<td><p>This method allows a node to perform a unicast on the channel,  and the method returns a tuple (node,received_signal) if the  signal can be decoded, or None.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="comm.transceiver.UserTransceiver.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">freq</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.UserTransceiver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the constructor.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.UserTransceiver.create_signal">
<code class="sig-name descname">create_signal</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal">comm.signalwave.QualityBasedSignal</a><a class="headerlink" href="#comm.transceiver.UserTransceiver.create_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signal for transmissioin. By default, the method creates
<a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">QualityBasedSignal</span></code></a> signal.</p>
</dd></dl>

<dl class="py method">
<dt id="comm.transceiver.UserTransceiver.multicast">
<code class="sig-name descname">multicast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span><span class="p">:</span> <span class="n"><a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal">comm.signalwave.QualityBasedSignal</a></span></em>, <em class="sig-param"><span class="n">node_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#comm.transceiver.UserTransceiver.multicast" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows a node to perform a multicast, 
and the method returns a list of tuple (node,received_signal)
that the multicast signal can be decoded, or None if no node can
decode the signal.
Note that this method can be used for unicast by putting a single node
in <cite>node_list</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>signal</strong><span class="classifier">any <a class="reference internal" href="comm.signalwave.html#comm.signalwave.BaseSignal" title="comm.signalwave.BaseSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.BaseSignal</span></code></a> subclass</span></dt><dd><p>The signal to be transmitted.</p>
</dd>
<dt><strong>node_list</strong><span class="classifier">a list of <a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a> subclass</span></dt><dd><p>The list containing the nodes to receive the multicast signal</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A list of tuple (<a class="reference internal" href="node.node.html#node.node.BaseNode" title="node.node.BaseNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">node.node.BaseNode</span></code></a>, <a class="reference internal" href="comm.signalwave.html#comm.signalwave.QualityBasedSignal" title="comm.signalwave.QualityBasedSignal"><code class="xref py py-class docutils literal notranslate"><span class="pre">comm.signalwave.QualityBasedSignal</span></code></a>)</dt><dd><p>It returns a list of (node,signal) that the node can decode the 
signal. An empty list is returned if no receiver can decode the signal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


              </div>
              
              
          </main>
          

      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2021, cfoh.<br/>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.4.3.<br/>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>